<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[DOS 命令小结]]></title>
      <url>/2018/01/09/DOS-%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="DOS命令简介"><a href="#DOS命令简介" class="headerlink" title="DOS命令简介"></a>DOS命令简介</h1><p>Dos命令可以在不借助其他编程语言和环境的情况下完成很多自动化的任务，今天刚好有个Windows服务器下的脚本需要定时调用，因此就学了一下基本的命令并在此记录，以备后用。</p>
<h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>echo 用来显示执行的命令或执行命令的结果「注：在bat脚本中两个冒号标示注释」</p>
<pre><code>bash
::打开echo回显，执行Dos命令之后不仅会显示命令本身，还会显示命令执行结果
echo on
::关闭echo回显，执行Dos命令之后不会显示命令本身，仅显示命令执行结果
echo off
::输出变量「DIR」到文件log.txt中,每次写入文件会覆盖之前的记录
echo %DIR%  &gt; log.txt
::输出变量「DIR」到文件log.txt中,每次写入文件会追加到log.txt文件末尾
echo %DIR%  &gt;&gt; log.txt
</code></pre><h2 id="文件及文件夹路径相关"><a href="#文件及文件夹路径相关" class="headerlink" title="文件及文件夹路径相关"></a>文件及文件夹路径相关</h2><p>Dos命令中可以直接使用内置变量来获取当前路径及文件的相关信息(<strong>注：</strong>下述命令中「I」为变量占位符，其中「0」代表执行文件本身，「1」代表「#1」，「2」代表「#2」…)</p>
<pre><code>bash
%~I         - 移除变量两边的引号 (&quot;)，例如「%~0」表示当前文件的全路径
%~fI        - 全路径
%~dI        - 仅包含驱动器路径
%~pI        - 仅包含路径
%~nI        - 仅包含文件名称
</code></pre><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><p>在Dos命令中，两个「%」包围起来的是我们定义的变量，如果变量是个字符串，我们可以在两个「%」中对该字符进行截断</p>
<pre><code>bash
%date%  -代表date字符串
%date:~2%  -标示date字符串由第二个字符开始往后所有字符
%date:~-2%  -标示date字符串由倒数第二个字符开始往前所有字符
%date:~2,5%  -标示date字符串由第二个字符开始往后5个字符
</code></pre><h2 id="FOR语法"><a href="#FOR语法" class="headerlink" title="FOR语法"></a>FOR语法</h2><p>FOR 语法中可以带多个参数其中「/R」表示递归查找， 「%%i」其中i为占位符，可以是任何<strong>单个</strong>字母，表示循环变量。in 后面的括号中可以利用正则匹配文件名称，如「*.txt」表示任何以「.txt」结尾的文件。</p>
<pre><code>bash
for /R %DIR% %%i in (*start.bat) do (
echo &quot;%%i&quot;  &gt;&gt; start.log
)
</code></pre><p>以上例子会将「DIR」路径下所有以start.bat结尾的文件输出到start.log中</p>
<h2 id="Call和Start"><a href="#Call和Start" class="headerlink" title="Call和Start"></a>Call和Start</h2><p>Call会调用命令或其他批处理，会等待调用的命令执行完毕然后再继续当前操作<br>Start会另外启动一个新的窗口来运行其他命令或批处理。也就是说Start命令会另起一个「线程」完成指定的任务。</p>
<p>此次使用DOS命令目的是定时执行我们服务器上一个目录下的所有脚本，以上是使用到的命令及相关介绍，配合Windows自身的「任务计划程序」，简单实用，非常好用。</p>
]]></content>
      
        <categories>
            
            <category> TECH </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DOS </tag>
            
            <tag> bat </tag>
            
            <tag> cmd </tag>
            
            <tag> 遍历文件夹，调用批处理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[微信支付接入注意事项]]></title>
      <url>/2017/12/14/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%8E%A5%E5%85%A5%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<h1 id="微信支付接入注意事项"><a href="#微信支付接入注意事项" class="headerlink" title="微信支付接入注意事项"></a>微信支付接入注意事项</h1><p>微信支付截止目前为止支持5种场景的接入，每一种场景需要特定的开发工作，列举如下：</p>
<ol>
<li>公众号支付，适用于在公众号、朋友圈、聊天窗口等微信内完成支付的场景。</li>
<li>APP支付，适用于在移动端APP中集成微信支付功能的场景。</li>
<li>扫码支付，适用于PC网站支付、实体店单品等场景。</li>
<li>刷卡支付，适用于线下面对面收银的场景，如超市、便利店等。</li>
<li>H5支付，适用于具有H5网页版商城，通过移动端网页调起微信客户端进行支付的场景。</li>
<li>微信买单，无需开发。</li>
</ol>
<h2 id="公众号支付"><a href="#公众号支付" class="headerlink" title="公众号支付"></a>公众号支付</h2><p>需要商户已有H5网站，在微信客户端内发起支付流程。</p>
<h3 id="公众号内配置"><a href="#公众号内配置" class="headerlink" title="公众号内配置"></a>公众号内配置</h3><p>公众号支付需要在H5页面通过JS接口发起微信支付申请，因此需要在公众号内设置JS接口安全域名。只有在设置的域名或路径下才有权限调用微信开放的JS接口。设置目录为：公众平台–&gt;设置–&gt;公众号设置–&gt;功能设置。<br>JS接口安全域名设置注意事项：</p>
<ol>
<li>最多可以添加3个域名或路径（建议写域名，这样域名下任何路径的H5页面均可以在微信中使用JS开放接口）</li>
<li>域名必须通过ICP备案</li>
<li>下载验证文件并放至服务器根目录，确保通过域名可以访问。例如域名设置为「m.jxedt.com」，则文件要放置的路径为「m.jxedt.com/MP_verify_XXX.txt」</li>
<li>最重要的一点，<strong>安全域名一个月仅能修改3次</strong>，确认好业务域名或路径后，尽量把三个域名全部利用起来。</li>
</ol>
<p><img src="../20171214/safe_domain.png" alt="安全域名设置"></p>
<h3 id="微信支付商户平台配置"><a href="#微信支付商户平台配置" class="headerlink" title="微信支付商户平台配置"></a>微信支付商户平台配置</h3><h4 id="支付授权目录配置"><a href="#支付授权目录配置" class="headerlink" title="支付授权目录配置"></a>支付授权目录配置</h4><p>公众号支付在请求支付的时候会校验请求来源是否有在商户平台做了配置，所以必须确保支付目录已经正确的被配置，否则将验证失败，请求支付不成功。<br>支付授权目录的配置路径：商户平台–&gt;产品中心–&gt;开发配置–&gt;支付配置</p>
<p><img src="../20171214/pay_jsapi.png" alt="支付授权目录配置"></p>
<h4 id="API证书下载及密钥设置"><a href="#API证书下载及密钥设置" class="headerlink" title="API证书下载及密钥设置"></a>API证书下载及密钥设置</h4><p>部分安全性要求较高的API需要使用API证书来确认调用者的身份，公众号支付中退款接口需要证书。</p>
<p>API密钥的作用：</p>
<blockquote>
<p>在API调用时用来按照指定规则对你的请求参数进行签名，服务器收到你的请求时会进行签名验证，既可以界定你的身份也可以防止其他人恶意篡改请求数据。部分API单独使用API密钥签名进行安全加固，部分安全性要求更高的API会要求使用API密钥签名和API证书同时进行安全加固。</p>
</blockquote>
<p>证书下载及密钥设置路径：商户平台–&gt;账户中心–&gt;账户安全–&gt;API安全<br><img src="../20171214/pay_cert.png" alt="API证书下载及密钥设置"></p>
<h3 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h3><p><img src="../20171214/pay_flow.png" alt="微信支付流程图"></p>
<h3 id="支付业务时序图"><a href="#支付业务时序图" class="headerlink" title="支付业务时序图"></a>支付业务时序图</h3><p><img src="../20171214/wechat_pay_timeline.png" alt="时序图"></p>
<h3 id="Server开发注意事项"><a href="#Server开发注意事项" class="headerlink" title="Server开发注意事项"></a>Server开发注意事项</h3><ul>
<li>微信有两套JS接口可以调起支付（JS-SDK和WeixinJSBridge），所有参数确保与对应的接口保持一致，包括大小写</li>
<li>统一订单生成时所使用的签名算法，与返回给H5页面的预支付信息中的<strong>签名算法必须保持一致</strong>。为确保不出现莫名签名失败问题，最好统一使用MD5.</li>
<li>支付回调接口，需做幂等处理，防止多次回调引起业务逻辑问题。</li>
<li><strong>订单查询功能</strong>可以查看当前订单的状态，进而处理下一步业务逻辑<ul>
<li>当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付通知；</li>
<li>调用支付接口后，返回系统错误或未知交易状态情况；</li>
<li>调用刷卡支付API，返回USERPAYING的状态；</li>
<li>调用关单或撤销接口API之前，需确认支付状态；</li>
</ul>
</li>
<li><strong>订单关闭功能</strong>使用场景（<strong>订单生成后5分钟内不能关单</strong>）<ul>
<li>商户订单支付失败需要生成新单号重新发起支付，要对原订单号调用关单，避免重复支付</li>
<li>系统下单后，用户支付超时，系统退出不再受理，避免用户继续，请调用关单接口</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> TECH </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信公众号支付 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[排序算法之冒泡排序及其优化]]></title>
      <url>/2017/10/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>冒泡排序是最笨的排序算法，得名于它的排序过程，即（以升序排序为例）：给定一个数组，比较相邻数值，若左侧数大于右侧，则交换两者；假定有N个数，则一趟排序需要比较N-1次，然后最大的数值在一轮比较之后被交换至最右侧。类似气泡往上冒一样，最大的数值依次往右边移动，故称为冒泡排序。</p>
<a id="more"></a>
<h1 id="冒泡排序特点"><a href="#冒泡排序特点" class="headerlink" title="冒泡排序特点"></a>冒泡排序特点</h1><p>冒泡排序最差的时间复杂度为O(n<sup>2</sup>),最好为O(n)，属于稳定排序，空间复杂度为O(1)。</p>
<h1 id="原始冒泡排序"><a href="#原始冒泡排序" class="headerlink" title="原始冒泡排序"></a>原始冒泡排序</h1><p>按照冒泡的基本思路实现的代码（Go版本）如下：</p>
<pre><code>func MainFunc (args []int) {
    swapTimes := len(args) - 1
    exchange, compare := 0,0
    for swapTimes &gt; 0 {
        bound := swapTimes
        for i := 0; i &lt; bound; i++ {
            compare++
            if args[i] &gt; args[i + 1] {
                exchange++
                args[i], args[i + 1] = args[i + 1], args[i]
            }
        }
        swapTimes--
    }
    fmt.Println(&quot;compare:&quot;, compare, &quot;exchange: &quot; , exchange)
    fmt.Println(args)
}
</code></pre><h1 id="优化冒泡排序"><a href="#优化冒泡排序" class="headerlink" title="优化冒泡排序"></a>优化冒泡排序</h1><p>对于基本有序的数组进行排序，其实可以做一下优化。当某次比较过程中发现并没有数据交换，那则表明该段数据已经有序，仅需记录该段数据的起始下标，对下标之前的数据进行排序即可，代码（Go版本）如下：</p>
<pre><code>func MainFuncQuickEnd(args []int) {
    flag := len(args) - 1
    exchange, compare := 0,0
    for flag &gt; 0 {
        limit := flag
        preExchange := exchange
        for i := 0; i &lt; limit; i++ {
            compare++
            if args[i] &gt; args[i + 1] {
                exchange++
                flag = i
                args[i], args[i + 1] = args[i + 1], args[i]
            }
        }
        if preExchange == exchange {
            break
        }
    }
    fmt.Println(&quot;compare:&quot;, compare, &quot;exchange: &quot; , exchange)
    fmt.Println(args)
}
</code></pre><h1 id="优化前后对比"><a href="#优化前后对比" class="headerlink" title="优化前后对比"></a>优化前后对比</h1><p>对于基本有序的数组，如{2,1,5,4,0,6,7,8,9}，进行排序，优化前需要比较36次，交换6次；优化后需要比较14次，交换6次。对于完全乱序的数组，两者差别并不是很大。</p>
]]></content>
      
        <categories>
            
            <category> TECH </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排序算法 </tag>
            
            <tag> 冒泡排序 </tag>
            
            <tag> go语言 </tag>
            
            <tag> golang 学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/09/30/%E4%B8%BA%E4%BB%80%E4%B9%88%20wait(),notify(),notifyAll()%20%E7%9A%84%E8%B0%83%E7%94%A8%E5%BF%85%E9%A1%BB%E5%9C%A8%20synchronized%20%E4%BB%A3%E7%A0%81%E4%B8%AD/</url>
      <content type="html"><![CDATA[<h1 id="为什么-wait-notify-notifyAll-的调用必须在-synchronized-代码中"><a href="#为什么-wait-notify-notifyAll-的调用必须在-synchronized-代码中" class="headerlink" title="为什么 wait(),notify(),notifyAll() 的调用必须在 synchronized 代码中"></a>为什么 wait(),notify(),notifyAll() 的调用必须在 synchronized 代码中</h1><p><strong>关键字</strong>：Java,多线程</p>
<p>Java中，任何对象都拥有一个Monitor的概念，这个Monitor拥有单独的一个锁，并拥有一个入队列和一个等待队列。没有被synchronized修饰的方法或语句，可以在任何时间被任何线程调用。而被synchronized修饰的方法同一时间仅能被一个拥有该对象锁的线程调用。当一个线程在调用synchronized方法时，另外的线程调用该方法时就被阻塞，并放入队列中。</p>
<p>多线程开发中，wait(),notify(),notifyAll()方法必须在synchronized方法或代码块中，否则会抛出运行时异常：<code>java.lang.IllegalMonitorStateException: current thread not owner</code>。因为要想调用这些方法，必须要保证调用方法的线程已经获取了该对象的锁。</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjWait</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                lock.wait();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Exception in thread <span class="string">"Thread-0"</span> java.lang.IllegalMonitorStateException</div><div class="line">	at java.lang.Object.wait(Native Method)</div><div class="line">	at java.lang.Object.wait(Object.java:<span class="number">502</span>)</div><div class="line">	at interrupt.ObjWait.lambda$main$<span class="number">0</span>(ObjWait.java:<span class="number">9</span>)</div><div class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</div></pre></td></tr></table></figure>
<h1 id="wait-方法会释放所持有的锁"><a href="#wait-方法会释放所持有的锁" class="headerlink" title="wait() 方法会释放所持有的锁"></a>wait() 方法会释放所持有的锁</h1><p>当一个线程在调用wait()方法时，该线程会释放当前所持有的锁，并进入等待队列。因此要想执行该方法，前提是必须拥有这个锁，而synchronized可以保证在执行wait()时，已经拿到了锁。</p>
<h1 id="什么情况下我们才会使用wait"><a href="#什么情况下我们才会使用wait" class="headerlink" title="什么情况下我们才会使用wait()"></a>什么情况下我们才会使用wait()</h1><p>在等待队列中的线程只会被notify()、notifyAll()唤醒并执行。</p>
<p>一般情况下，我们在调用wait()时，肯定会加上一个限定条件。也就是说在达到某个条件之后，我们才会让当前线程wait()。而notify()、notifyAll()也是在达到某个条件之后，我们才会去唤醒其他的等待线程。而这个条件就是线程间进行通信的一个互斥条件。</p>
<h1 id="生产者消费者模式解读"><a href="#生产者消费者模式解读" class="headerlink" title="生产者消费者模式解读"></a>生产者消费者模式解读</h1><p>以生产者消费者模式为例，消费者从缓存中取数据，生产者向缓存中写数据。消费者必须等生产者写入数据后才能取数据，生产者必须等消费者把数据取走之后才能向缓存中写数据。如果wait(),notify(),notifyAll()可以被任意方法调用，当消费者在读数据的时候，发现缓存为空，这时调用了wait()方法，而此时生产者也调用了notify()，告诉消费者有数据到达，这样消费者就永远接收不到这个通知，然后一直等下去。</p>
<p>因此，我们必须在synchronized方法中调用wait(),notify(),notifyAll()，从而互斥地拥有锁，从而保证不会丢失通知。</p>
<p>参考文章:<a href="http://www.xyzws.com/Javafaq/why-wait-notify-notifyall-must-be-called-inside-a-synchronized-method-block/127" target="_blank" rel="external">Why wait(), notify(), notifyAll() must be called inside a synchronized method/block?</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[微信支付签名问题汇总]]></title>
      <url>/2017/08/31/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%AD%BE%E5%90%8D%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>开发微信支付功能，遇到一些很难被发现的坑，在此记录，以防后患。</p>
<h1 id="公众号支付的场景"><a href="#公众号支付的场景" class="headerlink" title="公众号支付的场景"></a>公众号支付的场景</h1><p>商户已有H5商品页面，用户可以通过点击商城的购买链接或是扫二维码在微信客户端打开网页，从而进行支付。</p>
<a id="more"></a>
<h1 id="微信支付商户平台设置"><a href="#微信支付商户平台设置" class="headerlink" title="微信支付商户平台设置"></a>微信支付商户平台设置</h1><h2 id="支付授权目录配置"><a href="#支付授权目录配置" class="headerlink" title="支付授权目录配置"></a>支付授权目录配置</h2><p>登录<a href="https://pay.weixin.qq.com" target="_blank" rel="external">微信支付商户平台</a>，进入目录<strong>产品中心-开发配置-支付配置</strong>，在支付授权目录添加支付页面的目录。即：若支付页面为<code>https://domain.com/pay/pay.html</code>，则需要将<code>https://domain.com/pay/</code>添加到<strong>JSAPI支付授权目录</strong>下。</p>
<h2 id="支付API证书及密钥配置"><a href="#支付API证书及密钥配置" class="headerlink" title="支付API证书及密钥配置"></a>支付API证书及密钥配置</h2><p>部分API（如退款）的调用需要通过证书来确定调用者的身份，不涉及则可以不用设置。</p>
<p>如需配置，则需下载证书并放置到服务器安全目录，在调用相关接口时读取证书并使用，使用方法参考<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=11_1" target="_blank" rel="external">微信支付DEMO</a>。</p>
<h1 id="微信公众号设置"><a href="#微信公众号设置" class="headerlink" title="微信公众号设置"></a>微信公众号设置</h1><p>在H5页面进行支付时需要获取用户基本信息，因此还需在公众平台账户设置网页授权域名。登录微信公众号，<strong>公众号设置-功能设置-网页授权域名</strong>，添加测试或正式环境的域名；下载验证文件（类似MP<em>verify</em><em>.txt）并放置到服务器目录下。<em>*注意：该域名一个月内仅可修改3次，因此千万不要随便设置，以免影响开发</em></em></p>
<h1 id="支付流程及参数"><a href="#支付流程及参数" class="headerlink" title="支付流程及参数"></a>支付流程及参数</h1><p>公众号支付大部分流程在服务器端进行，H5页面仅需发起下单请求和支付请求就可以了。服务端请求统一下单API，成功调用后由返回的参数中获取预支付ID<strong>prepay_id</strong>，并生成支付参数返回给H5。参数格式参照<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6" target="_blank" rel="external">公众号支付参数说明</a>。<strong>注意：所有接口的参数都是大小写敏感的，因此最好拷贝各个参数而不是手动敲代码</strong></p>
<p>支付的流程如下：</p>
<p><img src="/20170930/wechat.pay.flowchart.png" alt="微信支付流程图"></p>
<p>隐藏的坑：</p>
<ol>
<li><p>若签名失败，则在<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=20_1" target="_blank" rel="external">签名校验地址</a>校验调用相关API的参数生成的签名是否正确</p>
</li>
<li><p>统一下单的接口中需要签名，返回给H5的支付参数中也有签名，<strong>两个签名的签名方式必须统一</strong>。</p>
</li>
</ol>
<ul>
<li><p>JS支付接口<code>getBrandWCPayRequest</code>仅支持MD5签名，所以统一下单接口必须使用MD5进行签名。</p>
</li>
<li><p>若使用JSAPI中的接口<code>WeixinJSBridge</code>进行支付，则默认为SHA1，而新版的微信支付使用的是MD5。因此综上所述，建议<strong>所有签名用MD5</strong></p>
</li>
</ul>
<p>第二个坑摸索了一天一夜，最终还是通过发邮件给微信的人才搞定。通过签名接口校验所有的签名都是校验通过，但是调起支付后还是通知签名失败，建议他们修改文档，然而没有卵用，依然没有任何提示。就这样吧，踩坑愉快！</p>
]]></content>
      
        <categories>
            
            <category> TECH </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信公众号支付 </tag>
            
            <tag> 微信支付 </tag>
            
            <tag> 签名 </tag>
            
            <tag> 支付签名校验失败 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[获取微信公众号所有历史文章(续)]]></title>
      <url>/2017/05/02/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E6%96%87%E7%AB%A0%EF%BC%88%E7%BB%AD%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>@(微信公众号小技巧)[微信公众号|所有历史文章]</p>
<p><strong>上一篇</strong>我们介绍了如何通过<strong>Fiddler</strong> 和 <strong>Chrome</strong> 得到知名大V所有历史文章的接口。那拿到接口之后该怎么办呢？你需要一个程序员，嗯！(ง •̀_•́)ง</p>
<blockquote>
<p><strong>郑重声明：</strong><br>该方法获取微信公众号历史文章仅供参考，请勿恶意使用。另外说明一下，微信本身&gt; 对于抓取数据的接口已经做了限制，如果频繁使用该接口进行数据抓取，微信会暂时&gt; 禁止当前微信号获取所有公众号的历史文章。目测当前的禁止时间为5分钟。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h2 id="接口简化"><a href="#接口简化" class="headerlink" title="接口简化"></a>接口简化</h2><p><strong>上一篇</strong>最后我们通过Chrome已经看到获取文章列表的URL<code>https://mp.weixin.qq.com/mp/profile_ext?action=getmsg&amp;__biz=MzI0MjA1Mjg2Ng==&amp;f=json&amp;frommsgid=1000000134XXXXX</code>, URL 太长，后面的大串字符我以<code>XXXXX</code>代替。格式化之后如下图所示</p>
</blockquote>
<p>为了简化接口，我们把没必要的参数删除，最后发现只有这几个参数是必须的</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数名</th>
<th style="text-align:left">参数值</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">action</td>
<td style="text-align:left">getmsg</td>
<td style="text-align:left">这个URL的目的是干嘛的？获取message（消息）的</td>
</tr>
<tr>
<td style="text-align:left">__biz</td>
<td style="text-align:left">MzI0MjA1Mjg2Ng==</td>
<td style="text-align:left">这个参数与微信公众号一一对应，每个公众号都不一样</td>
</tr>
<tr>
<td style="text-align:left">f</td>
<td style="text-align:left">json</td>
<td style="text-align:left">获取数据的格式是JSON</td>
</tr>
<tr>
<td style="text-align:left">frommsgid</td>
<td style="text-align:left">1000000134</td>
<td style="text-align:left">公众号文章的ID，该接口返回从该ID开始的10篇文章</td>
</tr>
</tbody>
</table>
<p>公众号历史文章以时间顺序排列，离当前时间最近的文章排在最前面，因此我们可以得到以下规律第一篇文章的ID为1000000142，后续应该是<strong>1000000141，1000000140… …1000000133</strong>，总共10个ID。在获取文章列表后，以最后一篇文章的ID作为拼接下一个URL的<strong>frommsgid</strong>，其他参数不变。这样就可以循环获取所有的历史文章了。</p>
<h2 id="自动化获取"><a href="#自动化获取" class="headerlink" title="自动化获取"></a>自动化获取</h2><p>我们知道了获取历史文章的规律后，接下来就是怎么通过程序来实现自动获取并输出内容。<br>URL <code>https://mp.weixin.qq.com/mp/profile_ext?action=getmsg&amp;__biz=MzI0MjA1Mjg2Ng==&amp;f=json&amp;frommsgid=1000000134</code> 是真实的可用的地址，在我的浏览器中执行的结果如下，其中参数已经通过红色框标注。</p>
<p>那你把这个URL拷贝到自己的浏览器中可用看到同样的结果吗？不出意外的话是不可以的。原因就是因为这个接口的正常使用是有条件的，那就是必须获得鉴权。那如何使得浏览器获得跟<strong>微信客户端</strong>同样的权利，然后再使用该接口呢？</p>
<p>这个就不用麻烦大家自己去测试接口了。经过测试发现在<strong>Fiddler</strong>最开始的响应中有两个Cookie的写入操作，如下图所示</p>
<p>我们将这两个Cookie写入浏览器，就可以通过以上简单的URL获取公众号历史文章了。另外如果想通过程序自动获取，那只需要在请求的时候带上这两个Cookie内容，并不断修改<strong>frommsgid</strong>就可以获取公众号所有的历史文章了。</p>
<p><code>最后再次说明一下，频繁请求会被禁止访问所有公众号的历史文章</code> ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄.  </p>
]]></content>
      
        <categories>
            
            <category> TECH </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信公众号历史文章 </tag>
            
            <tag> 所有历史文章 </tag>
            
            <tag> caoz的梦呓 </tag>
            
            <tag> 小道消息 </tag>
            
            <tag> 微信公众号 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[获取微信公众号所有历史文章]]></title>
      <url>/2017/04/25/%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%85%AC%E4%BC%97%E5%8F%B7%E6%89%80%E6%9C%89%E5%8E%86%E5%8F%B2%E6%96%87%E7%AB%A0/</url>
      <content type="html"><![CDATA[<h1 id="如何获取公众号所有历史文章"><a href="#如何获取公众号所有历史文章" class="headerlink" title="如何获取公众号所有历史文章"></a>如何获取公众号所有历史文章</h1><hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>微信公众号历史文章的查看大家都会，公众号里有历史文章可以翻阅。但要想看一年前的历史文章怎么办，一页一页翻？有人说历史文章可以搜索，那如果不记得文章内容或关键字怎么办。</p>
<p>那一天你正在查看某知名大V（譬如 caoz）的历史文章，看的津津有味，这个时候女朋友的微信来了，你说是回还是不回。回完微信，再次翻阅历史或者搜索又是一阵忙碌，内心很是崩溃。这里分享一个方法教大家如何获取微信公众号的所有历史文章，你需要准备以下几个软件：</p>
<p><strong>Fiddler</strong> ：HTTP 代理工具，可以帮我们找到公众号历史文章的链接地址<br><strong>chrome</strong> ：谷歌浏览器，可以帮我们查找微信公众号历史文章的链接规律<br><strong>微信 Windows 版</strong> ：为了方便操作，当然手机微信也可以，将手机代理改为 Fiddler 即可</p>
<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><p>安装 Fiddler 并将 Fiddler 设置为电脑全局代理。打开Fiddler，点击工具栏菜单Tools–&gt;Telerik Fiddler Options–&gt;Connections。设置代理端口并勾选作为系统代理选项<br><a id="more"></a></p>
<p>##访问公众号历史文章<br>通过 Windows 版微信访问公众号历史文章，以caoz的公众号（caoz的梦呓）为例。点击公众号历史文章按钮，查看 Fiddler 窗口中所展示的所有链接，右键点击蓝色链接（如下图）并拷贝该URL，在 Chrome 中打开链接，此时可以看到我们在浏览器中可以查看公众号的所有历史文章。</p>
<p>##获取公众号历史文章接口<br>在 Chrome 浏览器打开历史文章列表后，按F12打开 Chrome 的开发工具。如图所示选中XHR,在下拉公众号历史文章列表的过程中，我们可以看到有左边的链接和右边的结果。此时的结果是JSON字符串，由此我们可以断定这就是微信公众号历史文章的接口及结果集。</p>
<p><strong>注意</strong><br><code>图文版详情请关注下图公众号查看</code></p>
]]></content>
      
        <categories>
            
            <category> TECH </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 微信公众号历史文章 </tag>
            
            <tag> 所有历史文章 </tag>
            
            <tag> caoz的梦呓 </tag>
            
            <tag> 小道消息 </tag>
            
            <tag> 微信公众号 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown 官方教程内联（Inline）语法（二）]]></title>
      <url>/2017/04/01/Markdown%20%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E5%86%85%E8%81%94%EF%BC%88Inline%EF%BC%89%E8%AF%AD%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<hr>
<h2 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h2><p>内联元素指的是与行内元素，与块状元素相对应。主要包括链接，代码，强调，图片等元素。块状元素的 Markdown 语法可以参考<a href="https://v2say.com/2017/03/20/Markdown 官方教程块级（Block）语法（一）/" target="_blank" rel="external">上一篇</a></p>
<hr>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown 支持两种风格的链接: <strong>行内链接</strong> 和 <strong>引用链接</strong>。</p>
<p>两种风格的链接均用中括号扩起来 [ ]。<br><a id="more"></a><br>行内链接由两部分组成，方括号<code>[ ]</code>括起来的链接描述，以及紧跟方括号的链接地址，地址由括弧<code>( )</code>包围。括弧内可以选择为该链接添加标题。例如：</p>
<pre><code>   This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.
</code></pre><p>如果想要链接到当前服务器的页面，链接地址可以是相对地址：</p>
<pre><code>See my [About](/about/) page for details.   
</code></pre><p>引用类型的链接采用两对方括号进行表示，其中第一个方括号内容为链接的描述信息，第二个内容为链接的ID：</p>
<pre><code>This is [an example][id] reference-style link.
</code></pre><p>然后，你需要做的是在文档的任何位置，定义 ID 所对应的链接：</p>
<pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;
</code></pre><p>规则说明：</p>
<ul>
<li>ID 由方括号包围 ，距离左边距不超过 3 个空格</li>
<li>一个冒号</li>
<li>一个或多个空格</li>
<li>链接地址</li>
<li>链接标题—可以由单引号，双引号或者括号包围起来</li>
</ul>
<p>以下三种表达方式是等价的：</p>
<pre><code>[foo]: http://example.com/  &quot;Optional Title Here&quot;
[foo]: http://example.com/  &apos;Optional Title Here&apos;
[foo]: http://example.com/  (Optional Title Here)
</code></pre><p><strong>注意：</strong> 链接名称可以由字母，数字，空格等组成，但是链接是大小写不敏感的，即链接大小写是一样的：</p>
<pre><code>[link text][a]
[link text][A]
</code></pre><p>是一样的。</p>
<p>关于链接也可以简写如下：</p>
<pre><code>[Google][]
</code></pre><p>然后链接的定义如下：</p>
<pre><code>[Google]: http://google.com/
</code></pre><p>下面是一个使用的示范：</p>
<pre><code>I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

[1]: http://google.com/        &quot;Google&quot;
[2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
[3]: http://search.msn.com/    &quot;MSN Search&quot;
</code></pre><p>简写的方式如下：</p>
<pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        &quot;Google&quot;
  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;
</code></pre><p>为了对比写法上的区别，将行内链接的写法也贴出来：</p>
<pre><code>I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)
than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or
[MSN](http://search.msn.com/ &quot;MSN Search&quot;).
</code></pre><p>由此可以看出来，引用链接的方式看起来更加利于编写和阅读。</p>
<hr>
<h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>Markdown 使用 (<code>*</code>) 和 (<code>_</code>) 来标记强调的字符。单个 <code>*</code> 或 <code>_</code> 最终被转化为<br>HTML <code>&lt;em&gt;</code> 标签；两个 <code>*</code> 或 <code>_</code>最终被转化为 HTML<br><code>&lt;strong&gt;</code> 标签：</p>
<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre><p>将会转化为：</p>
<pre><code>&lt;em&gt;single asterisks&lt;/em&gt;

&lt;em&gt;single underscores&lt;/em&gt;

&lt;strong&gt;double asterisks&lt;/strong&gt;

&lt;strong&gt;double underscores&lt;/strong&gt;
</code></pre><p><strong>注意：</strong> <code>*</code> 和 <code>_</code> 两侧不能有空格，否则会被当作单独字符处理。如果想要单独输出以上两个字符，则需要在字符前加 <code>\</code> 做转义。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>我们可以使用两个 (<code>` </code>) 来包围表示一段代码：</p>
<pre><code>Use the `printf()` function.
</code></pre><p>将会转化为：</p>
<pre><code>&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre><p>在代码块中使用 `，必需在代码块起始和末尾加入多个`：</p>
<pre><code>``There is a literal backtick (`) here.``
</code></pre><p>在代码块内部，符合和尖括号会被自动转义为 HTML 实体：</p>
<pre><code>Please don&apos;t use any `&lt;blink&gt;` tags.
</code></pre><p>会被转化为：</p>
<pre><code>&lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre><hr>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Markdown 中的图片语法与链接类似，也分为行内图片和引用两种。</p>
<p>行内图片语法如下：</p>
<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
</code></pre><p>规则如下：</p>
<ul>
<li>语法说明字符<code>!</code>开头</li>
<li>一对方括号，包含图片的 <code>alt</code> 属性</li>
<li>一对括弧包含图片的地址，还可选择性的加上图片的标题 <code>title</code> </li>
</ul>
<p>引用型的图片语法如下：</p>
<pre><code>![Alt text][id]
</code></pre><p><code>id</code> 是图片的引用地址，其定义的语法与链接完全一致：</p>
<pre><code>[id]: url/to/image  &quot;Optional title attribute&quot;
</code></pre><p>该表示方法没有设置图片大小的语法，如果想要设置，则可以直接食用 HTML <code>&lt;img&gt;</code> 标签。</p>
<hr>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><hr>
<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>Markdown 支持为 URL 和 email 自动生成链接。你需要做的就是用尖括号把地址括起来：</p>
<pre><code>&lt;http://example.com/&gt;
</code></pre><p>Markdown 会将上面的句子转化为：</p>
<pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
</code></pre><p>email的自动链接与 URL 基本一致，不同的地方在于为了防止 email 地址被 spambots 处理，故进行了转义：</p>
<pre><code>&lt;address@example.com&gt;
</code></pre><p>会被 Markdown 解析为：</p>
<pre><code>&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre><p>在浏览器中可以被转化为可以点击的 email 地址 “address@example.com”</p>
<hr>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>Markdown 语法可以使用反斜线 <code>\</code> 来表示字符本身。如果想要在文字中展示 <code>*</code> ，则需要在 <code>*</code> 前加上反斜线：</p>
<pre><code>\*literal asterisks\*
</code></pre><p>Markdown 支持用反斜线的字符：</p>
<pre><code>\   反斜线
`   点号
*   星号
_   下划线
{}  大括号
[]  方括号
()  小括弧
#   井号
+    加号
-    减号
.   英文句号
!   感叹号
</code></pre>]]></content>
      
        <categories>
            
            <category> popular </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown Grammar </tag>
            
            <tag> JOHN GRUBER </tag>
            
            <tag> Markdown语法 </tag>
            
            <tag> 10分钟学会Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown 官方教程块级（Block）语法（一）]]></title>
      <url>/2017/03/20/Markdown%20%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B%E5%9D%97%E7%BA%A7%EF%BC%88Block%EF%BC%89%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Markdown 语法<br>参考：JOHN GRUBER「Markdown 语法作者」<a href="https://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">个人网站</a></p>
<p><strong>注:</strong> 该文档就是采用 Markdown 语法进行编辑的。</p>
<hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Markdown 标记语言产生的意义就是让文本编辑能够更容易的读和写。</p>
<p>Markdown 注重可读性。可发布的 Markdown 标记的文档应该是纯文本，不应该包含用来格式化的标记。Markdown 语法由标点符号标记，标点符号的选择尽量展示其最原始的含义。例如用<code>*</code>强调，<code>&gt;</code>表示引用等等。</p>
<p>Markdown 并不是 HTML 的替代品，它仅仅支持 HTML 的部分标签。HTML 是<strong>发布</strong>格式，Markdown 是<strong>书写</strong>格式。如果想要使用HTML中的其他标签，可以直接在Markdown文档中使用。</p>
<p>Markdown语法对块级别的HTML元素有使用限制，例如 <code>&lt;div&gt;</code>，<code>&lt;table&gt;</code>，<code>&lt;pre&gt;</code>，<code>&lt;p&gt;</code>等等。在使用的时候必须在块的头和尾加入空行，并且头和尾标记不能有缩进。</p>
<a id="more"></a>
<p>例如在Markdown文档中添加HTML表格语法如下:</p>
<pre><code>上一段落

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;table content&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

下一段落
</code></pre><p><strong>注意:</strong> Markdown语法在上述块内不起作用，例如在HTML块中使用<strong>强调</strong>不起作用。</p>
<p>内联级别的 HTML 标签，例如 <code>&lt;span&gt;</code>, <code>&lt;cite&gt;</code> 或者 <code>&lt;del&gt;</code> 可以在任何地方使用。和块级 HTML 标签不一样的地方就是，Markdown 语法<strong>会解析</strong>内联级别内的内容。</p>
<hr>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>在 HTML 中，<code>&lt;</code> 和 <code>&amp;</code> 需要特殊处理。<code>&lt;</code> 标示标签的开始，<code>&amp;</code> 标示HTML实体。如果要使用，必须采用 <code>&amp;lt;</code>和<code>&amp;amp;</code>来标示&lt;和&amp;。这个是比较麻烦的一点，例如要写“AT&amp;T”，在 Markdown 文档中必须写作 <code>AT&amp;amp;T</code>。甚至在文档中插入 URL，也需要转义，例如：</p>
<pre><code>https://v2say.com/popular?page=1&amp;num=10
</code></pre><p>必须写作：</p>
<pre><code>https://v2say.com/popular?page=1&amp;amp;num=10
</code></pre><p>需要记住以上必须转义的地方，例如 <code>&amp;copy</code> 即 &copy; 标示版权的标记就不需要转义。</p>
<hr>
<h2 id="区块标记"><a href="#区块标记" class="headerlink" title="区块标记"></a>区块标记</h2><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>一段话由一行或多行文本组成，并由一个或多个空行「仅包含tab 或 空格」隔开。如果想要另起一段，则在句末添加两个或多个空格，然后再回车。</p>
<hr>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>Markdown 支持两种标题标示法：</p>
<p>标题下方用等号或者短横标示，例如：<br>    大标题<br>   =<br>    小标题<br>    -</p>
<p><code>=</code> 和 <code>-</code> 的数量不限</p>
<p>用 <code>#</code> 在标题头部标示， <code>#</code> 后保留一个空格:</p>
<pre><code># 一号标题
## 二号标题
###### 六号标题
</code></pre><hr>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>Markdown 使用 <code>&gt;</code> 标示引用段落。最好在每行之前添加 <code>&gt;</code> :</p>
<pre><code>&gt; 这
&gt; 是
&gt; 引
&gt; 
&gt; 用
</code></pre><p>效果如下：</p>
<blockquote>
<p>这<br>是<br>引</p>
<p>用</p>
</blockquote>
<p>引用可以嵌套，需要在引用内部再添加一层 <code>&gt;</code>:</p>
<pre><code>&gt; 引用一
&gt;
&gt; &gt; 引用二
&gt;
&gt; 引用一
</code></pre><p>效果如下：</p>
<blockquote>
<p>引用一</p>
<blockquote>
<p>引用二</p>
</blockquote>
<p>引用一</p>
</blockquote>
<p>引用块可以包含其他 Markdown 元素, 包括 headers, lists, code:</p>
<pre><code>&gt; 1.   This is the first list item.
&gt; 2.   This is the second list item.
&gt; 
&gt; Here&apos;s some example code:
&gt; 
&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre><p>效果如下：</p>
<blockquote>
<ol>
<li>第一条</li>
<li>第二条</li>
</ol>
<p>代码段:</p>
<pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre></blockquote>
<hr>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>Markdown 支持有序和无序列表</p>
<p>无序列表以 <code>*</code>，<code>+</code>，<code>-</code> 在行首标示– 以下3种表示是等价的：</p>
<pre><code>*   Red
*   Green
*   Blue

+   Red
+   Green
+   Blue

-   Red
-   Green
-   Blue
</code></pre><p>有序列表由英文句号标示:</p>
<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre><p>如果某个列表中包含多个段落，保证每行起始距页边4个空格或一个tab。</p>
<pre><code>1.  第一段

    第二段

2.  第二条
</code></pre><p>在列表中添加引用， <code>&gt;</code> 符号需要缩进：</p>
<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre><p>效果如下：</p>
<ul>
<li><p>A list item with a blockquote:</p>
<blockquote>
<p>This is a blockquote<br>inside a list item.</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>引用代码块需要在行首添加4个空格或1个tab：</p>
<pre><code>代码块标示如下:

    public static void main(){
        return;
    }
</code></pre><p>效果如下：</p>
<pre><code>public static void main(){
    return;
}
</code></pre><p>代码块会持续到下一个无缩进的行或文章末尾。</p>
<p>在代码块中，<code>&amp;</code>，<code>&lt;</code> 和 <code>&gt;</code> 会自动转换为 HTML 实体，其他普通的 Markdown 语法不会被 Markdown 语法解析。例如：</p>
<pre><code>&lt;div class=&quot;footer&quot;&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;

**strong**
</code></pre><p>转化后如下：</p>
<pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;
    &amp;amp;copy; 2004 Foo Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre><hr>
<h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>由三个或以上的<code>*</code>，<code>-</code>标示水平分割线:</p>
<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre><hr>
]]></content>
      
        <categories>
            
            <category> popular </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JOHN GRUBER </tag>
            
            <tag> Markdown </tag>
            
            <tag> GitHub GFM Grammar </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
